# 5. 배열(=리스트)

#### [배열]

----

: 자료구조는 크게 `메모리 공간 기반 연속 방식( = 배열)`과 `포인터 기반의 연결 방식( = 연결 리스트)`으로 나뉜다.

: **어느 위치에나 O(1)에 조회 가능한 장ㅈ덤**

- **C에서의 배열(정적 배열 자료형)**

  : C에서 배열은 **크기를 지정하고(고정된 크기) 해당 크기만큼의 연속된 메모리 공간을 할당받는 작업 수행 자료형**

  : **한번 생성한 배열 크기 변경 불가능**

  : 물리 메모리에 배열 요소 값이 실제로 순서대로 배치

  ```
  // C
  int arr[5] = {4, 2, 14, 5}  // 물리메모리 상에 4, 2, 14, 5 순으로 저장됨.
  ```

  : 위의 배열은 **고정된 크기만큼의 연속된 메모리 할당**

  : 하지만, 이 방법은 실제 데이터 전체 크기 가늠 힘들고, 너무 작은/많은 영역 할당해서 문제 발생..

  : 그래서 **크기 지정안하고 자동으로 리사이징하는 배열인 동적 배열이 등장**

  <br>

- **동적 배열 자료형**

  : 대부분의 프로그래밍 언어에서 동적 배열 지원

  ```
  자바에서 ArrayList, C++에서 std::vector가 대표적인 동적 배열 자료형
  ```

  : **파이썬에서 리스트가 바로 동적 배열 자료형**

  : **파이썬 포함 대부분 자료형에서 정적 배열 따로 제공 X, 동적 배열(파이썬의 리스트)만 제공**

  <br>

- **동적 배열의 원리**

  : 미리 초기값 작게 잡아 배열 생성하고, 데이터 추가되면서 꽉 채워지면 늘려주고 모두 복사하는 식

  : 보통 **더블링(2배씩 늘려주는 방식)으로 늘려줌**

  : **그래서 자료 삽입시 보통 O(1)이지만, 용량차서 더블링해야하면, 새로운 메모리 공간에 더큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요해 O(n) 비용이 발생**

<br>

#### [배열 예제 문제]

----

1. 두수의 합 - 별1

   : 덧셈해 타겟만들 수 있는 배열의 두 숫자 인덱스를 리턴

   ```python
   nums = [2, 7, 11, 15], target = 9
   
   # 출력 [0, 1]
   ```

   ```python
   # 리트코드 - Two Sum
   nums = [2, 7, 11, 15]
   target = 9
   
   def twoSum(nums, target):
       nums_map = {}                     # 앞서 비교했던 값. 인덱스 저장위해 dict형 사용
       for i, num in enumerate(nums):
           if target-num in nums_map:      # 현재 num이 앞서 비교했던 num에 있으면 수행.
               return [nums_map[target-num], i]  # 해당값의 index 출력
           else:
               nums_map[num] = i
   
   print(twoSum(nums,target))
   ```

   : **투 포인터로 left, right 잡아서 하면 문제 발생 => 못품 ㅎㅎ..** (주의)

   <br>
   
2. **leetcode 121. Best Time to Buy and Sell Stock** - 별1

3. **leetcode 238. Product of Array Except Self** - 별2

   : 자신을 제외한 배열의 곱

   ```
   나누기쓰면 안됨..
   
     [1, 2, 3, 4]
   1  1  2  6
        24 12  4  1
        
   1  1  2 6
   24 12 4 1
   ----------
   24 12 8 6
   
   정답 : [24, 12, 8, 6]
   ```

   