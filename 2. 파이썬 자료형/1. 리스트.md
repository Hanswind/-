## [1. 리스트, 튜플, 해시(딕셔너리) in 파이썬]

#### [1. 리스트]

-----

  : 말그대로 순서대로 저장하는 시퀀스이자 변경가능한 목록
  : 입력 순서 유지, 내부적으로 동적 배열로 되어있음

  : list() / [ ]
  : 리스트 사용하면 나중에 스택이나 큐 관련 연산 모두 제공해 좋음

: 파이썬에서 리스트는 연속된 공간에 요소 배치하는 배열의 장점과 다양한 타입 연결해 배치하는 연결 리스트의 장점 모두 취한 형태

: 파이썬은 그래서 원시 타입인 배열 제공하지도 않는다. (리스트에서 모두 대체 가능..)

: **배열과 리스트 비교 5강 참고**

<br>

  **[리스트 주요 연산 시간 복잡도]**

| 연산           | 시간복잡도 | 설명                                                         |
| -------------- | ---------- | ------------------------------------------------------------ |
| len(a)         | O(1)       |                                                              |
| a[i]           | O(1)       |                                                              |
| a[i:j]         | O(k)       | 조회해야하는 객체 k개                                        |
| elem in a      | O(n)       | elem 이 리스트 내에 있는지 확인                              |
| a.count(elem)  | O(n)       | elem 요소 개수 리턴                                          |
| a.index(elem)  | O(n)       | elem 요소의 인덱스 리턴                                      |
| a.append(elem) | O(1)       |                                                              |
| a.pop()        | O(1)       | 스택                                                         |
| a.pop(0)       | O(n)       | 큐, **전체 복사 필요해서 O(n) 필요.. 큐 연산 쓸꺼면 O(1)에 가능한 데크 권장** |
| del a[i]       | O(n)       | i에 따라 다름. 최악이 O(n)                                   |
| a.sort()       | O(nlogn)   | 정렬. 팀소트 사용 (최선 O(n))                                |
| min(a), max(a) | O(n)       |                                                              |
| a.reverse()    | O(n)       |                                                              |

: 리스트는 **탐색(값 존재유무 확인) 하려할때 정렬된 경우에는 이진 검색이 효율적**

<br>

#### [리스트 활용]

----

```python
# 리스트 선언
a = list()           # a = [] 와 동일한 의미
```

```python
# 리스트에 요소 추가
리스트명.append(추가할 요소)  # 자동으로 리스트 맨 마지막에 추가된다. / 다양한 자료형 관리 가능 [3, '안녕'. True]
```

```python
# 리스트에 원하는 위치에 요소 추가
리스트명.insert(인덱스위치, 추가할 요소)   # 인덱스는 0부터 시작
```

```python
# 리스트에서 원하는 인덱스의 값 꺼내오기
리스트명[인덱스]
```

```python
# 리스트에서 부분 꺼내오기
리스트명[i:j]   # i번째 인덱스부터 j-1인덱스까지의 내용을 꺼내 부분 배열로 만든다	

리스트명[i:]   # i번재 인덱스 ~ 끝까지
리스트명[:j]   # 0 ~ j-1번재 인덱스까지
```

```python
# 리스트에서 단계 지정해 꺼내오기
리스트명[i:j:단계]   # 지정한 단계 값만큼 건너뛰어 불러온다

# ex
a[::2]   # 배열 전체에서 인덱스 0, 2, 4... 값만 추출
a[::-1]  # 배열 전체에서 역순추출 - 릿코드에서 공간복잡도 O(1)만줄때 오류발생. a[:] = a[::-1]처럼 사용 필요
```

```python
# 존재하지 않는 인덱스 조회 => IndexError 발생
# try문으로 처리하기
try:
	print(a[9])
except IndexError:
	print("존재하지 않는 인덱스")
```

```python
# 인덱스에서 값 삭제하기 - 두가지 방법 (인덱스로 삭제하기, 값으로 삭제하기)

# 1. 인덱스로 배열내 값 삭제하기
del 배열명[인덱스]

# 2. 값으로 배열내 값 삭제하기
배열명.remove(값)

# 3. 스택의 pop연산
배열명.pop()        # 배열의 맨 마지막 값 추출 O(1)
배열명.pop(인덱스)   # 배열에서 지정한 인덱스값 추출 O(n)
```

<br>

#### [리스트 구조]

----

: 리스트는 **일련의 포인터의 연속** (지정한 값 가르키고 있는 포인터 ) - 교재 그림 참조

=> 그래서 단일 리스트에서 다양한 자료형 저장 가능.

=> 그러나 위 와같이 각 자료형의 크기는 서로 달라, 이들ㅇㄹ 연속된 메모리 공간에 할당 불가능.

=> 결국 각각의 객체에 대한 참조로 구현할수 밖에 없다.

=> **그래서 인덱스 조회등의 작업이 모든 포인터의 위치 찾아가서 타입 코드 확인하고 값 일일이 살펴봐야 하는등의 추가적인 작업 필요해, 속도면에서 불리**

= 편리(리스트가 배열과 연결리스트의 장점 통합)하지만 속도 일부 희생!

