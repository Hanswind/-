

# 완전탐색 - 소풍

: 종만북 6.3, 6.4

<br>

#### [키워드]

----

- **재귀 응용의 정석**

  : 재귀하고 자료값 복귀

- **까다로운 완전탐색 문제**

  : 꼭 다시 한번 풀어보기!!!

<br>

#### [풀이]

-----

```
우선 학생수 크기 만큼의 2중 리스트를 생성
[False]*학생수를 학생수만큼 append 해주는 방식사용 ..  
([False]*학생수*학생수 방식사용하면 값 넣을때 넣어짐 - deep copy 문제)


그리고 입력해준 친구쌍에 대해 생성한 2중 리스트에 대응
ex) 0, 1이 친구면 A[0][1] = A[1][0] = True

그리고 재귀 함수에 이미 짝이루어진 학생인지 여부를 저장하는 배열 하나를 넣는다.
def countCase(taken):      // taken은 [False] * 학생수 인 배열이 초기값.

재귀함수 안에서는 우선
재귀함수 탈출 조건을 적어준다.
taken에 있는 값이 전부 True면 짝다 만들어진거기때문에 return 1

+) 이때 원래는 for문 돌려서 False 있으면 for문 break해서 이어서 재귀 시행하는 방식이였으나
이 방법 그대로 하면 중복된 케이스도 카운트 되어서 (0,1)(2,3) = (2,3)(1,0)과 같은 중복 카운트.

그래서 남아있는 학생들중에서 가장 번호 작은 학생을 짝지어주는 방식으로 하기 위해서
firstFree를 이용. 그리고 이를 이용해 탈출 조건 작성함.

이제 정답 카운트용 res = 0 을 만들어준다.

그리고 for문을 돌림 for문은 아까 찾은 짝 안지어진 가장 작은 번호의 학생 ( = firstFree) 다음부터 끝까지.
그리고 만약 해당 범위에서 짝이 안지어진 학생이 있으면
firstFree 학생과 추가로 찾은 학생을 True로 바꿔주고 재귀문을 실행하준다.

이때 우리는 총 짝지어질수 잇는 경우의 수를 카운트 하기 때문에
res += 함수(새로운 taken)
식으로 함.

그리고 마지막으로 재귀문을 돌려줬으니,
다른 case에 대해서도 확인하기 위해서 True로 바꿔줬던 애들을 다시 false로 바꿔주고 계속 for문 돌린다.

마무리로 끝까지 갔던 얘들은 1을 return 하기 때문에 이런 경우들을 다 더한 res를 return 해주면 끝.
```

