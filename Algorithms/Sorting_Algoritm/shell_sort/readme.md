# 쉘 정렬(Shell Sort) 알고리즘

- 삽입 정렬의 성질을 이용(보완)한 알고리즘
- 삽입 정렬의 최대 문제점인, 요소가 삽입될때, 이웃한 위치로만 이동하는 것을 부분 리스트를 이용해 개선
- **평균 시간 복잡도 : O(n^1.5)**   (시간 복잡도는 n^4/3과 n*logn^2로도 알려져있다. )
- 시간 복잡도에 대한 엄격한 상한선이나 최고의 증가 순서는 알려져 있지 않다.


### 사용처
---
: **적은 오버헤드, 상대적으로 쉬운 구현, 적응적 특성, 2차 이하의 시간 복잡성**을 보이기 때문에

  쉘 정렬은 **정렬할 데이터가 그리 크지 않을때, 일부 O(nlogn)정렬 알고리즘 실행 대안**으로서 사용된다.


### 간단 이론
---
```text
# 쉘 정렬 개념

1. 정렬해야할 리스트의 각 k번째 요소를 추출해 부분 리스트를 만든다 (k = 간격)
  ㄴ 간격의 초기값 : 보통 정렬할 수의 개수 / 2 으로 설정 (정렬할수 / 3 + 1의 방법이 더 빠름)
  

2. 부분 리스트들간 각 같은 자리의 값들을 삽입 정렬을 이용해 정렬

3. 이후 각 회전마다 간격 k를 절반으로 줄인다

4. 반복



# 쉘 정렬 예시

ex) list = [5,2,8,6,1,9,3,7]

1. 간격 = 8 / 2 = 4
 => [5,2,8,6] , [1,9,3,7] 로 부분 리스트 나눔
 
2. 부분 리스트들간 각 같은 자리의 값을 정렬
  [5,2,8,6]            [1,2,3,6]
  [1,9,3,7]     =>     [5,9,8,7]
  
3. 간격 감수 k = 2
 => [1,2] [3,6] [5,9] [8,7]
 
4. 반복
  [1,2]      [1,2]
  [3,6]  =>  [3,6]
  [5,9]      [5,7]
  [8,7]  =>  [8,9]
  
5. 간격 감수 k = 1
  1 2 3 6 5 7 8 9
  
6. 반복(삽입정렬)
  1 2 3 5 6 7 8 9  //완료
```