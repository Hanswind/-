# 병합 정렬(Merge Sort) 알고리즘

- 데이터를 분할한 다음 각자 계산하고 나중에 합쳐서 정렬하는 알고리즘
- **분할정복(Divide and Conguer) 알고리즘**의 대표적인 예씨
- **평균 시간 복잡도 : O(nlogn)** 
- 최선, 최악 시간 복잡도 : O(nlogn)  = **입력값과 상관없이 시간 복잡도 일정**


### 사용처
---

병합 정렬은 주로 공간 복잡성과 Copying 비용을 감소하는데 관심을 가진다.

또한 최소, 평균, 최대 시간 복잡도가 동일함을 보이며, linked list를 정렬하는데 유용한다.

### 간단 이론
---
##### [병합 정렬 예시]

![병합 정렬](../../../Objects/merge.png)

1. 정렬할 데이터를 최소 단위(1개)가 될때까지 분할 작업 반복(재귀) - Divide
2. 분할된 데이터를 대상으로 2개, 4개, 8개... 씩 병합하며 정렬을 수행 - Conquer

```
ex) list = [5,2,8,6,1,9,3,7]

1. 분할 => [5,2,8,6] [1,9,3,7]
2. 분할 => [5,2] [8,6] [1,9] [3,7]
3. 분할 => [5] [2] [8] [6] [1] [9] [3] [7]
4. 병합정렬 => [2,5] [6,8] [1,9] [3,7] 
5. 병합정렬 => [2 5 6 8] [1 3 7 9]
6. 병합정렬 => [1 2 3 5 6 7 8 9]
```



##### [2차 정렬 알고리즘]

: 병합 정렬에서 두개의 subarray를 병합하는 방법

```
: 병합 대상의 두 배열은 이미 정렬된 상태이다.
: 이 두 배열의 맨 앞 요소끼리 비교해 더 작은(큰) 값을 먼저 배치한다.
: 수가 빠진 배열의 다음 비교 요소는 그 다음 값이다


# 2차 정렬 알고리즘 예시
[2,5] [6,8] => []
비교 대상 : 2, 6
[5], [6,8] => [2]
비교 대상 : 5, 6
```

### 의사코드

-----

```
MERGE-SORT(A, p, r)
  if p < r
    q = floor[(p+r)/2]
    MERGE-SORT(A,p,q)       // 분할
    MERGE-SORT(A,q+1,r)     // 분할
    MERGE(A,p,q,r)          // 정복
    
    
MERGE(A,p,q,r)
  n1 = q-p+1
  n2 = r-q
  배열 L[1:n1+1], R[1:n2+1] 생성    // A에 두 subarray 붙어서 온거 잘라줌 
  L, R 2차 정렬 알고리즘(생략)
```



### +)더보기 : 분할정복 시간복잡도 증명

------

- 분할정복 알고리즘은 기본적으로 3단계로 구성 : 분할, 정복, 결합

<br>

**1. 분할**

  : 부분 배열의 **중간 위치** 계산  => **최악 시간복잡도 : Θ(1)**

**2. 정복**

  : 2개의 Subarray를 재귀적으로 푼다 => 각 Subarray 크기 : n/2 =>**수행시간 : 2T(n/2)**

```
ex) n = 2
 -> 부분 집합 크기 : 1             * 수행시간 : 2T(1)
 
ex) 4개의 원소 (n = 4)
 -> 부분집합 크기 : 2
 -> 한번더 푼 부분집합 크기 : 1     * 수행시간 : 2T(2)
```

: 배열의 크기 n에 따라 2T() 내부 숫자 값이 커진다**(앞에 2는 반으로 나누는거기때문에 변화 X)**

**3. 결합**

: 분할된거 merge 작업 => **최악 시간복잡도 : Θ(n)** 

  (두 배열에서 일정규칙으로 값빼서 하나의 배열로 만듬 - for문 1단으로 가능)

<br>

**[병합정렬 최악 수행시간 T(n)에 대한 점화식]**

```
T(n) =  if n=1   then Θ(1)
        if n>1   then 2T(n/2)+Θ(n)
```



```
이때, 배열의 크기가 cn이라고 해보자.
cn의 배열의 크기는 분할과정을 거치며 cn/2, cn/4 ... c 으로 분할한다.


다음으로, 트리의 각 레벨에서 비용을 본다.
최상 레벨에선 cn이 한개라 비용 : cn
다음 레벨에선 cn/2이 2개라 비용 : cn
...
결국 모든 레벨에서 각 비용이 cn임을 알 수 있다.


그리고, 배열의 크기가 cn인 트리가 c까지 분할될때 총 레벨수는 logn + 1의 크기이다.
 ex) cn = 8 이면 트리 레벨 : 4 (8 -44 -2222- 1111111) = log8 + 1
 
 
마지막으로, 점화식의 총 비용을 알아보려면 모든 레벨의 비용을 더하면 된다.
  최상 레벨(레벨 0) 에서 cn 한개 -> 0 * cn
  레벨 1 에서 cn/2 2개 -> 1 * cn
  ...
결국 (logn + 1) * cn 이라는 일반식을 도출할 수 있다.


결론) 점화식의 총 비용 : cn(logn + 1) 이다.
여기서 시간복잡도로 표현 하기위해 낮은 차수와 상수(cn, c)를 제거하면 시간복잡도 O(nlogn)이 도출된다.
```





